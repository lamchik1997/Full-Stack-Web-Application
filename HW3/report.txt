Objective 1 + Objective 2:
These two objectives requested us to handle the POST request. In the handle function , I will first parse the request line to see if the request type is POST. If it’s the case, we will then check if the request path is /comment,if so, we will continue to parse the multipart/form-data. First I will separate the data by splitting on \r\n\r\n. The first part is the header and the second part is the body. Then I will call parse header function to parse my header and return a dictionary containing all the key and value from the header. Since it’s a multipart form data, it will read the boundary from the header dictionary and set the boundary to be ‘--’ + boundary from dictionary. Next I will parse the body by calling parseBody function giving the body data, boundary and also a random generating string (this is for the extra credit). My parseBody function will parse the data using the boundary and return the result using a dictionary and the status (status is used for the extra credit) . After getting the dictionary, I will check if the user submitted a invalid text (>, < ,&) ,if so, my checkForAttack function would convert the sting to the corresponding HTML escape character. Then my server will generate a message with the user input name and comment.We will append it to the respond list which have all the previous user submission and add that to my HTML template by calling editHTML function with the respond list and the random String(for extra credit)to generate a responses and display back to the user. Since we finished the objective 2, the objective 1 can simply sent a 301 response and redirected back to the html home page.

Objective 3 + Objective 4:
For these two objectives, our server will need to save the uploaded file and store the submitted data. Server will respond with a confirmation page that contains the uploaded image and caption. In order to accomplish this, we will parse our header in the same way as obj 1+2 above. After getting the header dictionary, in addition to reading the boundary ,we will also need to read the content length from the header dictionary. First ,we set the data variable recording how many bytes we received so far, and set the read variable to zero. While our read variable is less than the content_length, we continue calling the request.recv(2048) to buffer our data .Once our read variable reach the content length ,we can stop and parse the body. Similar to obj1 and obj2 , we called our function parseBody to handle the body parsing and return us a dictionary with the data. From the returned dictionary, we find the upload key and write the image file into our file system and store it user the /userPic directory. We also need to check if the caption value contain any invalid character. If so, we will convert it to the HTML escape character. Then we added the user provided image with the corresponding caption to the message and append the message to our respond list. Then we can safely call our editHTML function with our respond list and also the random str(for the token)to generate a HTTP response and sent it to our client.
 
